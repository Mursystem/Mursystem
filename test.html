<!DOCTYPE html>
<html>

<head>
    <title>RTC/Websocket</title>
</head>

<body>
    <h1>WebSocket/RTC Example</h1>
    <video id="localVideo" width="320" height="240" autoplay muted></video>
    <video id="remoteVideo" autoplay muted></video>
    <textarea id="chatLog" rows="10" cols="50"></textarea><br>
    <input type="text" id="messageInput" placeholder="Type your message"><br>
    <button id="sendMessageButton">Send Message</button>
    <script>
        let receiveChannel;
        let sendChannel;
        let localConnection;
        let remoteConnection;
        let who = null;


        const socket = connectWebSocket();
        const iceConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };

        function connectWebSocket() {
            const socket = new WebSocket('wss://magic-websocket.onrender.com');
            socket.addEventListener('open', (event) => {
                console.log('Connected to the WebSocket server.');
            });
            socket.addEventListener('message', (event) => {
                const message = event.data;
                // Parse the message
                const parsedMessage = JSON.parse(message);
                // Check the message type
                if (parsedMessage.type === 'welcome') {
                    console.log(parsedMessage.message);
                }
                if (parsedMessage.type === 'role') {
                    // Check if the role is for Peer A
                    if (parsedMessage.role === 'peerA') {
                        handlePeerA();
                    }
                    // Check if the role is for Peer B
                    else if (parsedMessage.role === 'peerB') {
                        who = "peerB";
                        socket.send(JSON.stringify({ type: 'ready' }));
                    }
                }
                if (parsedMessage.type === 'offer') {
                    if (who == "peerB") {
                        handlePeerB(parsedMessage.offer);
                    }
                }
                if (parsedMessage.type === 'answer') {
                    if (who == "peerA") {
                        console.log('answer detected on PeerA');
                        handleAnswer(parsedMessage.answer);
                    }
                }
            });
            socket.addEventListener('close', (event) => {
                console.log('Disconnected from the WebSocket server.');
            });
            return socket;
        }

        function handleAnswer(answer) {
            localConnection.setRemoteDescription({ type: "answer", sdp: answer })
                .then(() => {
                    console.log("Remote description set successfully on PeerA");
                })
                .catch(error => {
                    console.error('Error setting remote description:', error);
                });
        }

        function handlePeerA() {
            who = "peerA";
            console.log("Peer A");

            localConnection = new RTCPeerConnection(iceConfiguration);

            sendChannel = localConnection.createDataChannel('sendChannel');
            //sendChannel.onmessage = receiveMessage;
            sendChannel.onopen = () => {
                console.log('Data channel opened!');
            };
            sendChannel.onclose = () => console.log('Data channel closed!');

            localConnection.onnegotiationneeded = async () => {
                try {
                    console.log('sending offer');
                    const offer = await localConnection.createOffer();
                    await localConnection.setLocalDescription(offer);
                    socket.send(JSON.stringify({ type: 'offer', offer: localConnection.localDescription.sdp }));
                } catch (error) {
                    console.error('Error creating offer:', error);
                }
            };

            localConnection.onicegatheringstatechange = (event) => {
                console.log('ICE gathering state:', localConnection.iceGatheringState);
                if (localConnection.iceGatheringState === 'complete') {
                    console.log('ICE gathering complete! Send your offer now.');
                }
            };
        }
        // ...

        function handlePeerB(sdp) {
            console.log("Peer B - Step 2");

            remoteConnection = new RTCPeerConnection(iceConfiguration);

            remoteConnection.onicecandidate = e => {
                console.log("NEW ice candidate!! on remoteConnection reprinting SDP");
            };

            remoteConnection.ondatachannel = e => {
                receiveChannel = e.channel;
                receiveChannel.onopen = () => console.log("Data channel opened!");
                receiveChannel.onclose = () => console.log("Data channel closed!");
            };

            remoteConnection.setRemoteDescription({ type: "offer", sdp: sdp })
                .then(() => {
                    console.log("Remote description set successfully!");
                    return remoteConnection.createAnswer();
                })
                .then(answer => {
                    return remoteConnection.setLocalDescription(answer);
                })
                .then(() => {
                    socket.send(JSON.stringify({ type: 'answer', answer: remoteConnection.localDescription.sdp }));
                    console.log('Sent Answer!');
                })
                .catch(error => {
                    console.error('Error setting remote description or creating answer:', error);
                });
        }

// ...


    </script>
</body>

</html>