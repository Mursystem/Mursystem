<!DOCTYPE html>
<html>

<head>
    <title>RTC/Websocket</title>
</head>

<body>
    <h1>WebSocket/RTC Example</h1>
    <video id="localVideo" width="320" height="240" autoplay muted></video>
    <video id="remoteVideo" autoplay muted></video>
    <textarea id="chatLog" rows="10" cols="50"></textarea><br>
    <input type="text" id="messageInput" placeholder="Type your message"><br>
    <button id="sendMessageButton">Send Message</button>
    <script>
        let receiveChannel;
        let sendChannel;
        let localConnection;
        let remoteConnection;
        let who = null;


        const socket = connectWebSocket();
        const iceConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };

        function connectWebSocket() {
            const socket = new WebSocket('wss://magic-websocket.onrender.com');
            socket.addEventListener('open', (event) => {
                console.log('Connected to the WebSocket server.');
            });
            socket.addEventListener('message', (event) => {
                const message = event.data;
                // Parse the message
                const parsedMessage = JSON.parse(message);
                // Check the message type
                if (parsedMessage.type === 'welcome') {
                    console.log(parsedMessage.message);
                }
                if (parsedMessage.type === 'role') {
                    // Check if the role is for Peer A
                    if (parsedMessage.role === 'peerA') {
                        handlePeerA();
                    }
                    // Check if the role is for Peer B
                    else if (parsedMessage.role === 'peerB') {
                        who = "peerB";
                        socket.send(JSON.stringify({ type: 'ready' }));
                    }
                }
                if (parsedMessage.type === 'offer') {
                    if (who == "peerB") {
                        handlePeerB(parsedMessage.offer);
                    }
                }
                if (parsedMessage.type === 'answer') {
                    if (who == "peerA") {
                        console.log('Answer detected on peerA');
                        handleAnswer(parsedMessage.answer);
                        console.log(parsedMessage.answer);
                    }
                }
            });
            socket.addEventListener('close', (event) => {
                console.log('Disconnected from the WebSocket server.');
            });
            return socket;
        }

        function handleAnswer(answer) {

            localConnection.setRemoteDescription({ type: "answer", sdp: answer })
                .then(() => {
                    console.log("Remote description set successfully on Peer A");
                })
                .catch(error => {
                    console.error('Error setting remote description:', error);
                });
        }


        function handlePeerA() {
            who = "peerA";
            console.log("Peer A");

            localConnection = new RTCPeerConnection(iceConfiguration);

            sendChannel = localConnection.createDataChannel("sendChannel");
            sendChannel.onmessage = e => console.log("messsage received!!!" + e.data)
            sendChannel.onopen = e => console.log("open!!!!");
            sendChannel.onclose = e => console.log("closed!!!!!!");



            localConnection.onnegotiationneeded = async () => {
                try {
                    console.log('Sending offer');
                    const offer = await localConnection.createOffer();
                    await localConnection.setLocalDescription(offer);
                    socket.send(JSON.stringify({ type: 'offer', offer: localConnection.localDescription.sdp }));
                } catch (error) {
                    console.error('Error creating offer:', error);
                }
            };

            localConnection.onicegatheringstatechange = (event) => {
                console.log('ICE gathering state:', localConnection.iceGatheringState);
                if (localConnection.iceGatheringState === 'complete') {
                    console.log('ICE gathering complete! Send your offer now.');
                }
            };
        }


        function handlePeerB(sdp) {
            console.log("Peer B");

            remoteConnection = new RTCPeerConnection(iceConfiguration);

            remoteConnection.onicegatheringstatechange = event => {
                console.log('ICE gathering state:', remoteConnection.iceGatheringState);
                if (remoteConnection.iceGatheringState === 'complete') {
                    console.log('ICE gathering complete! Proceed with the connection.');

                    socket.send(JSON.stringify({ type: 'answer', answer: remoteConnection.localDescription.sdp }));
                    console.log('Sent Answer!');

                }
            };


            remoteConnection.ondatachannel = e => {

                receiveChannel = e.channel;
                receiveChannel.onmessage = e => console.log("messsage received!!!" + e.data)
                receiveChannel.onopen = e => console.log("open!!!!");
                receiveChannel.onclose = e => console.log("closed!!!!!!");
                remoteConnection.channel = receiveChannel;

            }
            remoteConnection.setRemoteDescription({ type: "offer", sdp: sdp })
                .then(() => {
                    console.log("Remote description set successfully!");
                    return remoteConnection.createAnswer();
                })
                .then(answer => {
                    return remoteConnection.setLocalDescription(answer);
                })
                .catch(error => {
                    console.error('Error setting remote description or creating answer:', error);
                });
        }


// ...


    </script>
</body>

</html>