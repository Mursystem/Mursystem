<!DOCTYPE html>
<html>

<head>
    <title>RTC/Websocket</title>
</head>

<body>
    <h1>WebSocket/RTC Example</h1>
    <video id="localVideo" width="320" height="240" autoplay muted></video>
    <video id="remoteVideo" autoplay muted></video>
    <textarea id="chatLog" rows="10" cols="50"></textarea><br>
    <input type="text" id="messageInput" placeholder="Type your message"><br>
    <button id="sendMessageButton">Send Message</button>
    <script>
        let receiveChannel;
        let sendChannel;
        let localConnection;
        let remoteConnection;
        let who = null;
        let iceDone = null;

        const socket = connectWebSocket();
        const iceConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };

        function connectWebSocket() {
            const socket = new WebSocket('wss://magic-websocket.onrender.com');
            socket.addEventListener('open', (event) => {
                console.log('Connected to the WebSocket server.');
            });
            socket.addEventListener('message', (event) => {
                const message = event.data;
                // Parse the message
                const parsedMessage = JSON.parse(message);
                // Check the message type
                if (parsedMessage.type === 'welcome') {
                    console.log(parsedMessage.message);
                }
                if (parsedMessage.type === 'role') {
                    // Check if the role is for Peer A
                    if (parsedMessage.role === 'peerA') {
                        handlePeerA();
                    }
                    // Check if the role is for Peer B
                    else if (parsedMessage.role === 'peerB') {
                        handlePeerB();
                    }
                }
                if (parsedMessage.type === 'offer') {
                    if (who == "peerB") {
                        console.log('Offer detected on peerB');
                        handleOffer(parsedMessage.offer);
                    }
                }
                if (parsedMessage.type === 'request') {
                    if (who == "peerA") {
                        console.log('Request detected on peerB');
                        localConnection.onnegotiationneeded();
                    }
                }
                if (parsedMessage.type === 'answer') {
                    if (who == "peerA") {
                        console.log('Answer detected on peerA');
                        handleAnswer(parsedMessage.answer);

                    }
                }
            });
            socket.addEventListener('close', (event) => {
                console.log('Disconnected from the WebSocket server.');
            });
            return socket;
        }

        function handleAnswer(answer) {

            localConnection.setRemoteDescription({ type: "answer", sdp: answer })
                .then(() => {
                    console.log("Remote description set successfully on Peer A, All done!");
                })
                .catch(error => {
                    console.error('Error setting remote description:', error);
                });
        }
        function handleOffer(offer) {

            remoteConnection.setRemoteDescription({ type: "offer", sdp: offer })
                .then(() => {
                    console.log("Remote description set successfully!");

                    remoteConnection.createAnswer()
                        .then(answer => {
                            remoteConnection.setLocalDescription(answer).then(e => {
                                console.log("Local Description set");
                                if (iceDone) {
                                    socket.send(JSON.stringify({ type: 'answer', answer: remoteConnection.localDescription.sdp }));
                                }
                            })
                        })

                })
                .catch(error => {
                    console.error('Error setting remote description or creating answer:', error);
                });
        }

        function handlePeerA() {
            who = "peerA";
            console.log("Peer A");

            localConnection = new RTCPeerConnection(iceConfiguration);
            // Add the media stream to the connection
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    const localVideo = document.getElementById("localVideo");
                    localVideo.srcObject = stream;
                    stream.getTracks().forEach(track => {
                        localConnection.addTrack(track, stream);
                    });
                })
                .catch(error => {
                    console.error('Error accessing media devices:', error);
                });
            // Create a data channel
            sendChannel = localConnection.createDataChannel("sendChannel");
            sendChannel.onmessage = e => console.log("message received:", e.data);
            sendChannel.onopen = () => console.log("data channel opened");
            sendChannel.onclose = () => console.log("data channel closed");

            localConnection.onnegotiationneeded = async () => {
                try {
                    console.log('Sending offer to server');
                    const offer = await localConnection.createOffer();
                    await localConnection.setLocalDescription(offer);
                    socket.send(JSON.stringify({ type: 'offer', offer: localConnection.localDescription.sdp }));
                } catch (error) {
                    console.error('Error creating offer:', error);
                }
            };

            localConnection.onicegatheringstatechange = event => {
                console.log('ICE gathering state:', localConnection.iceGatheringState);
                if (localConnection.iceGatheringState === 'complete') {
                    console.log('ICE gathering complete! Send your offer now.');
                }
            };
            localConnection.ontrack = event => {
                const remoteVideo = document.getElementById("remoteVideo");
                if (!remoteVideo.srcObject) {
                    remoteVideo.srcObject = event.streams[0];
                }
            };
        }

        function handlePeerB() {
            who = "peerB";
            console.log("Peer B");
            remoteConnection = new RTCPeerConnection(iceConfiguration);
            // Add the media stream to the connection
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    const localVideo = document.getElementById("localVideo");
                    localVideo.srcObject = stream;
                    stream.getTracks().forEach(track => {
                        remoteConnection.addTrack(track, stream);
                    });
                })
                .catch(error => {
                    console.error('Error accessing media devices:', error);
                });

            remoteConnection.onnegotiationneeded = e => {
                console.log(e);
                socket.send(JSON.stringify({ type: 'request', request: "send an offer"}));
            }

            remoteConnection.onicegatheringstatechange = event => {
                console.log('ICE gathering state:', remoteConnection.iceGatheringState);
                if (remoteConnection.iceGatheringState === 'complete') {
                    iceDone = 'complete';
                    console.log('ICE gathering complete! Send your answer now.');
                    socket.send(JSON.stringify({ type: 'answer', answer: remoteConnection.localDescription.sdp }));
                }
            };

            remoteConnection.ondatachannel = e => {

                receiveChannel = e.channel;
                receiveChannel.onmessage = e => console.log("message received:", e.data);
                receiveChannel.onopen = () => console.log("data channel opened");
                receiveChannel.onclose = () => console.log("data channel closed");
                remoteConnection.channel = receiveChannel;
            }

            remoteConnection.ontrack = event => {
                const remoteVideo = document.getElementById("remoteVideo");
                if (!remoteVideo.srcObject) {
                    remoteVideo.srcObject = event.streams[0];
                }
            };


        }

    </script>
</body>

</html>